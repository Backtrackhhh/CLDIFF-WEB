<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="style.css">
	<link rel="stylesheet" href="codemirror/lib/codemirror.css">
	<link rel="stylesheet" href="codemirror/theme/colorforth.css">
	<link rel="stylesheet" href="codemirror/addon/scroll/simplescrollbars.css">
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="codemirror/lib/codemirror.js"></script>
	<script src="codemirror/addon/scroll/simplescrollbars.js"></script>
	<script src="codemirror/mode/javascript/javascript.js"></script>

</head>

<body>
	<svg width="1800" height="1800" style="border:1px solid black"></svg>

	<script src="https://d3js.org/d3.v4.min.js" type="text/javascript"></script>
	<script src="https://d3js.org/d3-selection-multi.v1.js"></script>

	<script type="text/javascript">
		var colors = d3.scaleOrdinal(d3.schemeCategory10);

		var svg = d3.select("svg"),
			width = +svg.attr("width"),
			height = +svg.attr("height"),
			node,
			link,
			labelPadding = 3;

		var simulation = d3.forceSimulation()
			.force("link", d3.forceLink().id(function(d) {
				return d.id;
			}))
			.force("charge", d3.forceManyBody()
				.strength(function(d) {
					return +500;
				}))
			.force('collide', d3.forceCollide(230).strength(1.5).iterations(3))
			.force("center", d3.forceCenter(900, 900));

		d3.json("graph.json", function(error, graph) {
			if (error) throw error;
			update(graph.links, graph.nodes);


			function update(links, nodes) {
				link = svg.selectAll("g")
					.data(links)
					.enter().append("line")
					.attr("class", function(d) {
						return "link " + d.type;
					})
					.style("opacity", "0.7")
					.attr("marker-end", function(d) {
						return "url(#" + d.type + ")";
					});

				//			link.append("title")
				//				.text(function(d) {
				//					return d.type;
				//				});


				node = svg.selectAll(".node")
					.data(nodes)
					.enter()
					.append("g")
					.attr("class", "nodes");

				node.append("rect").attr("class", "rect")
					.attr("x", -165)
					.attr("y", -50)
					.attr("width", 300)
					.attr("height", 100)
					.style("fill", function(d, i) {
						return colors(i);
					})
					.call(d3.drag()
						.on("start", dragstarted)
						.on("drag", dragged)
						.on("end", dragended))
					.on("dblclick", connectedNodes);


				//						node.append("text")
				//							.attr("dy", -10)
				//							.text(function(d) {
				//								return d.code;
//				//							});
				node.append("foreignObject")
					.attr("width", 320)
					.attr("height", 120)
					.attr("x", -150)
					.attr("y", -58)
					.attr("id", "textarea")
					.append("xhtml:body")
					.append('textarea')
					.attr("id", function(d) {
						return "node" + d.id;
					})
					.text(function(d) {
						return d.code;
					})


				var node_length = node._groups[0].length;
				//				console.log(node_length);

				for (i = 0; i < node_length; i++) {
					var bik = (i);
					//					console.dir(typeof("node" + bik));
					//					console.log("node" + bik)
					var myTextArea = document.getElementById("node" + bik);
					var editor = CodeMirror.fromTextArea(myTextArea, {
						lineNumbers: true,
						mode: "javascript",
											theme: 'default',
						scrollbarStyle: "simple",

					});
				}

				edgepaths = svg.selectAll(".edgepath")
					.data(links)
					.enter()
					.append('path')
					.attrs({
						'class': 'edgepath',
						'fill-opacity': 0.1,
						'stroke-opacity': 0.9,
						'id': function(d, i) {
							return 'edgepath' + i
						}
					})
					.style("pointer-events", "none");

				edgelabels = svg.selectAll(".edgelabel")
					.data(links)
					.enter().append('text')
					.style("pointer-events", "none")
					.attrs({
						'class': 'edgelabel',
						'id': function(d, i) {
							return 'edgelabel' + d.type
						},
						'font-size': 10,
						//					'fill': 'red'
					});


				edgelabels.append("textPath")
					.attr('xlink:href', function(d, i) {
						return '#edgepath' + i
					})
					.style("text-anchor", "middle")
					.style("pointer-events", "none")
					.attr("startOffset", "50%")
					.text(function(d) {
						return d.text;
					});
					


				svg.append('defs').selectAll('marker')
					.data(["Type57", "Type56", "Type58"])
					.enter().append("marker")
					.attrs({
						'id': function(d) {
							return d;
						},
						'viewBox': '-0 -5 10 10',
						'refX': 92,
						'refY': 0,
						'orient': 'auto',
						'markerWidth': 10,
						'markerHeight': 10,
						'xoverflow': 'visible'
					})
					.append('path')
					.attr('d', 'M 0,-5 L 10 ,0 L 0,5');

				simulation
					.nodes(nodes)
					.on("tick", ticked);

				simulation.force("link")
					.links(links)
					.distance([400]);
			}

			function ticked() {
				link
					.attr("x1", function(d) {
						return d.source.x;
					})
					.attr("y1", function(d) {
						return d.source.y;
					})
					.attr("x2", function(d) {
						return d.target.x;
					})
					.attr("y2", function(d) {
						return d.target.y;
					});

				node
					.attr("transform", function(d) {
						return "translate(" + Math.max(170, Math.min(width - 160, d.x)) + "," + Math.max(60, Math.min(height - 60, d.y)) + ")";
					});

				edgepaths.attr('d', function(d) {
					return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y;
				});

				edgelabels.attr('transform', function(d) {

					var bbox = this.getBBox();

					rx = bbox.x + bbox.width / 2;
					ry = bbox.y + bbox.height / 2;
					return 'rotate(92 ' + rx + ' ' + ry + ')';

				});
			}

			function dragstarted(d) {
				if (!d3.event.active) simulation.alphaTarget(0.3).restart();
				d.fx = d.x;
				d.fy = d.y;
			}

			function dragged(d) {
				d.fx = d3.event.x;
				d.fy = d3.event.y;
			}

			function dragended(d) {
				if (!d3.event.active)
					simulation.alphaTarget(0.3).stop();
				d.fx = null;
				d.fy = null;
			}

			//Toggle stores whether the highlighting is on
			var toggle = 0;

			//Create an array logging what is connected to what
			var linkedByIndex = {};
			for (i = 0; i < graph.nodes.length; i++) {
				linkedByIndex[i + "," + i] = 1;
			};
			graph.links.forEach(function(d) {
				linkedByIndex[d.source.index + "," + d.target.index] = 1;
			});

			//This function looks up whether a pair are neighbours  
			function neighboring(a, b) {
				return linkedByIndex[a.index + "," + b.index];
			}

			function connectedNodes() {

				if (toggle == 0) {
					//Reduce the opacity of all but the neighbouring nodes
					d = d3.select(this).node().__data__;
					node.style("opacity", function(o) {
						return neighboring(d, o) | neighboring(o, d) ? 1 : 0.2;
					});

					link.style("opacity", function(o) {
						return d.index == o.source.index | d.index == o.target.index ? 0.5 : 0.1;
					});

					edgelabels.style("opacity", function(o) {
						return d.index == o.source.index | d.index == o.target.index ? 1 : 0.1;
					});


					//Reduce the op

					toggle = 1;
				} else {
					//Put them back to opacity=1
					node.style("opacity", 1);
					link.style("opacity", 0.5);
					edgelabels.style("opacity", 1);
					toggle = 0;
				}

			}

		})
	</script>

</body>
</html>